### 单链表

### 双链表
### 环形链表

### 带哨兵节点链表
> （1）带哨兵节点的链表，需要一个额外节点，但插入和删除等操作不需要额外的判断；

> 不带哨兵节点的链表，在处理链表为空时，和其他情况不一样，需要单独判断一次

> （2）带哨兵节点的链表，插入或删除时，不论操作的位置，表头都不变，不需要额外的判断；

> 不带哨兵节点的链表，插入或者删除操作发生在第一节点时，表头指针都要发生变化，需要额外的处理

#### 栈的基本概念和性质

* 栈ADT及其顺序

（1）`ADT`：
  Init_Stack(s)         栈初始化
  Empty_Stack(s)        判栈空
  Push_Stack(s)         入栈
  Pop_Stash(s)          出栈
  Top_Stash(s)          读栈顶元素

（2）顺序： 先进后出

（3）定义：
```c
// 顺序栈的定义
typedef struct {
  int data[maxSize];
  int top;
}sqStack;

// 链栈节点定义
typedef struct LNode{
  int data;
  struct LNode *next
}LNode;

```

#### 队列的基本概念和性质

* 队列ADT及其顺序
（1）`ADT`：
  Init_Queue(q)         栈初始化
  Empty_Queue(q)        判队空操作
  In_Queue(q)           入队列
  Out_Queue(q)          出队列
  Front_Queue(q)        读队头元素

（2）顺序： 先进先出

（3）定义：
```c
// 顺序队列的定义
typedef struct {
  int data[maxSize];
  int front;            // 队首指针
  int rear;             // 队尾指针
}

// 链队定义
typedef struct QNode{
  int data;
  struct QNode *next
}QNode

typedef struct{
  QNode *front;         // 队头指针
  QNode *rear;          // 队尾指针
}

* 队列的应用

// 顺序队进队算法
int enQueue(SqQueue &qu, int x){
  if((qu.rear + 1) % maxSize == qu.front){ // 队满的判断条件
    return 0;
  }

  qu.rear = (qu.rear + 1) % maxSize;       // 若队未满，则先移动指针
  x = qu.data[qu.front];                       // 再取出数据
  retuen 1;
}

// 顺序队进队算法
int deQueue(SqQueue &qu, int &x){
  if(qu.front == qu.rear){                 // 若队空，则不能出队
    return 0;
  }

  qu.front = (qu.front) % maxSize;         // 若队不空，则先移动指针
  x = qu.data[qu.front];                   // 再取出数据
  return 1;
}


#### 向量基本概念和性质

* 向量ADT及其数组、链接实现

向量是数组的抽象和泛化，由一组元素按线性次序封装而成。各元素与其相应的秩一一对应，采用循秩访问的方式，使对各元素的操作，管理维护更加简单，统一与安全。向量的元素类型可以灵活选取，便于定制复杂的数据结构。

* 其他：
（1）向量对于数组有什么优缺点：
优点：

    不指定一块内存大小的数组的连续存储，即可以像数组一样操作，可以对此数组进行动态操作，通常体现在push_back()、pop_back()

    随机访问方便，即支持[]操作符和vector.at()

    节省空间

缺点：

    在内部进行插入删除操作效率低

    只能在vector的最后进行push和pop，不能在头部进行push和pop

    当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放









