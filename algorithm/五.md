### 1、图的基本概念

（1）`有向图`
（2）`无向图`
（3）`简单图`
（4）`多重图`
（5）`子图`
（6）`连通、连通图和连通分量`
（7）`强连通图、强连通分量`
（8）`生成树、生成森林`
（9）`顶点的度、入度和出度`
（10）`边的权和网`
（11）`稠密图、稀疏图`
（12）`路径、路径长度和回路`
（13）`简单路径、简单回路`
（14）`距离`
（15）`有向树`：一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树
（16）`完全树（也称简单完全树）`

### 2、图的存储结构

（1）邻接矩阵

```c

#define MaxVertexNum 100                // 顶点数目的最大值

typedef char VertexType;                // 顶点数据类型
typedef char VertexType;                // 带权图中边上权值的数据类型
typedef struct{
  VertexType Vex[MaxVertexNum];        // 顶点表
  EdgeType Edge[MaxVertexNum][MaxVertexNum];    //边表
  int vexnum, arcnum;                  // 图的当前顶点数和弧度
}MGraph;

```

（2）邻接表

```c

#define MaxVertexNum 100               // 顶点数目的最大值

typedef struct ArcNode {               // 边表节点
  int adjvex;                          // 该弧所指向的顶点的位置
  struct ArcNode *next;                // 指向下一条弧的指针
  // InfoType info;                    // 网的边权值
}ArcNode;

typedef struct VNode{                  // 顶点表节点
  VertexType data;                     // 顶点信息  
  ArcNode *first;                      // 指向第一条依附该顶点的弧的指针
}VNode, AdjList[MaxVertexNum];

typedef struct {
  AdjList vertices;                    // 邻接表
  int vexnum,arcnum;                   // 图的顶点数和弧度
}ALGraph;                              // ALGraph是以邻接表存储的图类型

```

### 3、广度优先遍历和深度优先遍历

（1）`广度优先遍历（BFS）`
  
  ```c

  bool visited[MAX_VERTEX_NUM];               // 访问标记数组

  void BFSTraverse(Graph G){                  // 对G进行广度优先遍历
    for(i = 0; i < G.vexnum; ++i){
      visited[i] = FALSE;                     // 访问标记数组初始化
    }
    InitQueue(Q);                             // 初始化辅助队列Q
    for(i = 0; i < G.vexnum; ++i){            // 从0号顶点开始遍历
      if(!visited){                           // 对每个连通分量调用一次BFS
        BFS(G, i);                            // vi未访问过从vi开始BFS
      }
    }
  }

  void BFS(Graph G, int v){                   // 从顶点v出发，广度优先遍历图G
    visit(v);                                 // 访问初始顶点v
    visited[v]=TRUE;                          // 对v做已访问标记
    EnQueue(Q, v);                            // 顶点v入队列Q

    while(!isEmpty(Q)){
      DeQueue(Q, v);                          // 顶点v出队列
      for(w=FirstNeighbor(G, v); w>=0; w=NextNeighbor(G, v, w)){ // 检测v所有邻接点
        if(!visited[w]){                      // w为v的尚未访问的邻接顶点
          visit(w);                           // 访问顶点w
          visited[w]=TRUE;                    // 对w做已访问标记
          EnQueue(Q, w);                      // 顶点w入队列
        }
      }
    }
  }

  ```

（2）`深度优先遍历`

  ```c

  bool visited[MAX_VERTEX_NUM];                // 访问标记数组
  void DFSTraverse(Graph G){
    for(v = 0; v < G.){

    }
  }

  ```

### 4、最小生成树基本概念

### 5、Prim算法

### 6、Kruskal算法

### 7、最短路径问题

（1）`基于BFS`
  ```c
  void BFS_MIN_Distance(Graph G, int u){
    
    for(i = 0; i < G.vexnum; ++i){                  // d[i] 表示从u到i节点的最短路径
      d[i] = '∞';                                   // 初始化路径长度
    }
    visited[u] = TRUE;
    d[u] = 0;
    EnQueue(Q, u);
    while(!isEmpty(Q)){                             // BFS算法主过程
      DeQueue(Q, u);                                // 队头元素u出队
      for(w = FirstNeighbor(G,u); w >= 0; w=NextNeighbor(G, u, w)){
        if(!visited[w]){                            // w为u的尚未访问的邻接顶点       
          visited[w] = TRUE                         // 设已访问标记
          d[w]=d[u] + 1;                            // 路径长度加1
          EnQueue(Q, w);                            // 从顶点w入队
        }
      }
    }
  }
  ```

### 8、Dijkstra算法

### 9、Floyd算法


### 10、拓扑排序